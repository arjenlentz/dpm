PRACTICE:

WORK # write helper routines to serialize/deserialize length coded binaries
DONE ### pull in as many GPL'ed defines as possible, write own for others.
DONE ### create packet header with a ptype enum, func ptr to free, tobuf, tolua/fromlua
write deserialize for fields and rows
write packet-free routines. Clean up the memory leak I created.
intercept and set flags properly for compression/prepare support disabling
implement mysql's password crypto handshake
learn to handle large mysql packets (at least identify them, and bomb saying
they're not supported)
shuffle functions to be more in order
move run_protocol and mysql specific 'stuff' to mysql.c
move con and definition structures to toast.h
look up TCP options.. SO_KEEPALIVE, SO_LINGER, etc
more libevent infrastructure; timers
memory management; caching connection shit. malloc big range. reuse buffers.
use multiple .c files to make the program.
write a makefile
not all of the state machine names make sense; clean it up.
if buffer grows too big, shrink it after completing a write/read
use struct buffer sizes from mysql_com.h

Plans:

As packets are processed, foward up into lua.
call lua with tables: conn, packet

It is lua's job to request backend connections.
As new connections come in, lua can request a backend and attach two
connections as a proxy at any point.
get called at final packet of a request as well; can 'break' the proxy chain.
try to do auth from within lua.
bubble flags up to lua as tables.
figure out the best way to differentiate flagsets from enumerations.
run lua once at init.
listening sockets should be established from lua?
requests should know the listening socket for client connections...
so: listen ip/port can signify something.
otherwise use other features?
Figure out if SQL comments can be sent to the server correctly...
need ability to enqueue client events:

client sends COM_QUERY request
lua identifies and shelves the request packet in an internal array.
lua builds an array of packets:
'show status'
'COM_QUERY'
'show status'
pops first request, executes. at end of execution lua returns with the same
context. pop COM_QUERY, do same, pop show status, do same. compare results,
log to file.

schedule timer events from lua; 'come back with a reference to this
table/state at this time' - could create a backend connection, and run SHOW
PROCESSLIST once per second, reoccurring. No client needed...

Unique connection id
Stats tracking (?) (bytes, queries, uptime, etc)

DONE ### redo packet state machine to do proper state transitions when packets are _sent_ to a remote host.
DONE ### figure out how to free if (ptr == NULL) { don'tfree } correctly
DONE ### set libevent to listen on socket with callback, accept sockets.
DONE ### signal ignore sigpipe
DONE ### handle reading data on socket, printing locally.
DONE ### handle SIGHUP
DONE ### handle writing data back to socket
NAH  ### try basic ragel implementation to handle reading/writing commands
WORK # embed lua; pass input commands to lua, allow callback to set config vars
DONE ### proper read/write buffering for event sockets.
DONE ### outbound connection support. non-block connect()
DONE ### Full proxy support; must recognize mysql packets?
DONE ### write buffer resizing for large packets.
DONE ### (fixed some nice bugs) test running two connections at once
DONE ### learn about the authentication packets. print out the known data.
