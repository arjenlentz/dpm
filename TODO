PRACTICE:

write C outbound_connect
add to lua (return conn object)
add "attach to" C call for lua for attaching a proxy
have lua make backend connects and attach

stages to client auth:
*- on handle of new client, create handshake packet object
   ( requires client object, handshake packet object )
*- Set callback handler for auth return
*- Write handshake packet to wire
 - Upon auth return, receive conn obj and auth pkt
 - C call for checking the scramble stage against an argument string
   (PASSWORD("whatever") hash)
 - support for __gc to close a connection (or setting it to nil) (TODO: Shit proper error to wire)

stages to server auth:
 - request new outbound connection: outbound = new_backend("ip", port)
   ( 'outbound' is a conn struct )
 - register callback for handshake packet return
 - parse handshake packet, create auth packet object
 - C call for setting scramble for auth packet object
 - Write auth packet to wire
 - Callback on waiting auth result. handle OK or ERR

At this stage, client or server should be authenticated. register proper
callbacks. fill in the holes.

BONUS: Filter flags out of client abilities that we can't handle.

need a "verify" conn obj method that barfs if client conn was closed
WORK # write helper routines to serialize/deserialize length coded binaries
WORK # write deserialize for fields and rows
write packet-free routines. Clean up the memory leak I created.
intercept and set flags properly for compression/prepare support disabling
WORK ## implement mysql's password crypto handshake
learn to handle large mysql packets (at least identify them, and bomb saying
they're not supported)
look up TCP options.. SO_KEEPALIVE, SO_LINGER, etc
more libevent infrastructure; timers
memory management; caching connection shit. malloc big range. reuse buffers.
write a makefile
not all of the state machine names make sense; clean it up.
if buffer grows too big, shrink it after completing a write/read
use struct buffer sizes from mysql_com.h

DONE ### flesh out obj_index to handle read/write correctly.
DONE ### add read/write defines
DONE ## create working accessors for int, uint64_t, uint32_t, enum flag, bit flag
WORK ## create working accessors for uint16_t, uint8_t, null terminated strings
WORK ## create working accessor for length encoded strings
WORK ## attach __gc methods to free objects

DONE ### move con and definition structures to toast.h
DONE ### fix username reading; add +1 to my_size so it gets the \0
DONE ### use multiple .c files to make the program.
DONE ### pull in as many GPL'ed defines as possible, write own for others.
DONE ### create packet header with a ptype enum, func ptr to free, tobuf, tolua/fromlua
DONE ### redo packet state machine to do proper state transitions when packets are _sent_ to a remote host.
DONE ### figure out how to free if (ptr == NULL) { don'tfree } correctly
DONE ### set libevent to listen on socket with callback, accept sockets.
DONE ### signal ignore sigpipe
DONE ### handle reading data on socket, printing locally.
DONE ### handle SIGHUP
DONE ### handle writing data back to socket
NAH  ### try basic ragel implementation to handle reading/writing commands
WORK # embed lua; pass input commands to lua, allow callback to set config vars
DONE ### proper read/write buffering for event sockets.
DONE ### outbound connection support. non-block connect()
DONE ### Full proxy support; must recognize mysql packets?
DONE ### write buffer resizing for large packets.
DONE ### (fixed some nice bugs) test running two connections at once
DONE ### learn about the authentication packets. print out the known data.
