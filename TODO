Blockers for release-1:

BUGS TO KILL:
 - Client->proxy handshake fails randomly. When reading random data into
   scramble-buf, ensure no \0
 - Really need a callback on handle_close, feels like a bug without it.

- Reorganize files
*(bugged)- Create command packet so lua may at least inspect in-flight SQL
- Garbage collect packets
- Non-parsing "proxy" mode (optional)
*(almost)- Shut up the verbosity. Add -v or -d flag to make some of it come back
  (optional)
(after release) gitweb.cgi setup

- Need new luaobj string handlers:
  - One for a non-pointer string (*whatever)
  - One for a pointer string (**whatever?)
  - One for each that uses a message_len instead of strlen
  - One for each that uses a DEFINE for max length.

Nice, meaty TODO:

can probably force "max buffer size" of MAX_PACKET_SIZE. write some logic for
it.
don't allow connecting a backend if the conn is invalid
connection close callback
better mechanism for detecting closed conn?
RUN_UNTIL - somehow set the next state before packet is fully parsed again
start really garbage collecting all generated packets.
_if parsed_ - make sure it goes up into lua. make sure __gc works as expected.
handle case of client not supplying password, user not needing one

BONUS: Filter flags out of client abilities that we can't handle.

need a "verify" conn obj method that barfs if client conn was closed
WORK # write helper routines to serialize/deserialize length coded binaries
WORK # write deserialize for fields and rows
write packet-free routines. Clean up the memory leak I created.
WORK ## implement mysql's password crypto handshake
learn to handle large mysql packets (at least identify them, and bomb saying
they're not supported)
look up TCP options.. SO_KEEPALIVE, SO_LINGER, etc
more libevent infrastructure; timers
memory management; caching connection structs. malloc big range. reuse buffers.
not all of the state machine names make sense; clean it up.
if buffer grows too big, shrink it after completing a write/read

DONE ### use struct buffer sizes from mysql_com.h
DONE ### flesh out obj_index to handle read/write correctly.
DONE ### add read/write defines
DONE ## create working accessors for int, uint64_t, uint32_t, enum flag, bit flag
WORK ## create working accessors for uint16_t, uint8_t, null terminated strings
WORK ## create working accessor for length encoded strings
WORK ## attach __gc methods to free objects
DONE ### move con and definition structures to toast.h
DONE ### fix username reading; add +1 to my_size so it gets the \0
DONE ### use multiple .c files to make the program.
DONE ### pull in as many GPL'ed defines as possible, write own for others.
DONE ### create packet header with a ptype enum, func ptr to free, tobuf, tolua/fromlua
DONE ### redo packet state machine to do proper state transitions when packets are _sent_ to a remote host.
DONE ### figure out how to free if (ptr == NULL) { don'tfree } correctly
DONE ### set libevent to listen on socket with callback, accept sockets.
DONE ### signal ignore sigpipe
DONE ### handle reading data on socket, printing locally.
DONE ### handle SIGHUP
DONE ### handle writing data back to socket
NAH  ### try basic ragel implementation to handle reading/writing commands
WORK # embed lua; pass input commands to lua, allow callback to set config vars
DONE ### proper read/write buffering for event sockets.
DONE ### outbound connection support. non-block connect()
DONE ### Full proxy support; must recognize mysql packets?
DONE ### write buffer resizing for large packets.
DONE ### (fixed some nice bugs) test running two connections at once
DONE ### learn about the authentication packets. print out the known data.
